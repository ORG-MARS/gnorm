// Package pg contains the types for schema 'information_schema'.
package pg

// GENERATED BY XO. DO NOT EDIT.

import (
	"github.com/pkg/errors"
)

// ReferentialConstraintTable is the database name for the table.
const ReferentialConstraintTable = "information_schema.referential_constraints"

// ReferentialConstraint represents a row from 'information_schema.referential_constraints'.
type ReferentialConstraint struct {
	ConstraintCatalog       SQLIdentifier `yaml:"constraint_catalog,omitempty"`        // constraint_catalog
	ConstraintSchema        SQLIdentifier `yaml:"constraint_schema,omitempty"`         // constraint_schema
	ConstraintName          SQLIdentifier `yaml:"constraint_name,omitempty"`           // constraint_name
	UniqueConstraintCatalog SQLIdentifier `yaml:"unique_constraint_catalog,omitempty"` // unique_constraint_catalog
	UniqueConstraintSchema  SQLIdentifier `yaml:"unique_constraint_schema,omitempty"`  // unique_constraint_schema
	UniqueConstraintName    SQLIdentifier `yaml:"unique_constraint_name,omitempty"`    // unique_constraint_name
	MatchOption             CharacterData `yaml:"match_option,omitempty"`              // match_option
	UpdateRule              CharacterData `yaml:"update_rule,omitempty"`               // update_rule
	DeleteRule              CharacterData `yaml:"delete_rule,omitempty"`               // delete_rule
}

// Constants defining each column in the table.
const (
	ReferentialConstraintConstraintCatalogField       = "constraint_catalog"
	ReferentialConstraintConstraintSchemaField        = "constraint_schema"
	ReferentialConstraintConstraintNameField          = "constraint_name"
	ReferentialConstraintUniqueConstraintCatalogField = "unique_constraint_catalog"
	ReferentialConstraintUniqueConstraintSchemaField  = "unique_constraint_schema"
	ReferentialConstraintUniqueConstraintNameField    = "unique_constraint_name"
	ReferentialConstraintMatchOptionField             = "match_option"
	ReferentialConstraintUpdateRuleField              = "update_rule"
	ReferentialConstraintDeleteRuleField              = "delete_rule"
)

// WhereClauses for every type in ReferentialConstraint.
var (
	ReferentialConstraintConstraintCatalogWhere       SQLIdentifierField = "constraint_catalog"
	ReferentialConstraintConstraintSchemaWhere        SQLIdentifierField = "constraint_schema"
	ReferentialConstraintConstraintNameWhere          SQLIdentifierField = "constraint_name"
	ReferentialConstraintUniqueConstraintCatalogWhere SQLIdentifierField = "unique_constraint_catalog"
	ReferentialConstraintUniqueConstraintSchemaWhere  SQLIdentifierField = "unique_constraint_schema"
	ReferentialConstraintUniqueConstraintNameWhere    SQLIdentifierField = "unique_constraint_name"
	ReferentialConstraintMatchOptionWhere             CharacterDataField = "match_option"
	ReferentialConstraintUpdateRuleWhere              CharacterDataField = "update_rule"
	ReferentialConstraintDeleteRuleWhere              CharacterDataField = "delete_rule"
)

// QueryOneReferentialConstraint retrieves a row from 'information_schema.referential_constraints' as a ReferentialConstraint.
func QueryOneReferentialConstraint(db XODB, where WhereClause, order OrderBy) (*ReferentialConstraint, error) {
	const origsqlstr = `SELECT ` +
		`constraint_catalog, constraint_schema, constraint_name, unique_constraint_catalog, unique_constraint_schema, unique_constraint_name, match_option, update_rule, delete_rule ` +
		`FROM information_schema.referential_constraints WHERE (`

	
	sqlstr := origsqlstr + where.String() + ") " + order.String() + " LIMIT 1"

	rc := &ReferentialConstraint{}
	err := db.QueryRow(sqlstr, where.Values()...).Scan(&rc.ConstraintCatalog, &rc.ConstraintSchema, &rc.ConstraintName, &rc.UniqueConstraintCatalog, &rc.UniqueConstraintSchema, &rc.UniqueConstraintName, &rc.MatchOption, &rc.UpdateRule, &rc.DeleteRule)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	return rc, nil
}

// QueryReferentialConstraint retrieves rows from 'information_schema.referential_constraints' as a slice of ReferentialConstraint.
func QueryReferentialConstraint(db XODB, where WhereClause, order OrderBy) ([]*ReferentialConstraint, error) {
	const origsqlstr = `SELECT ` +
		`constraint_catalog, constraint_schema, constraint_name, unique_constraint_catalog, unique_constraint_schema, unique_constraint_name, match_option, update_rule, delete_rule ` +
		`FROM information_schema.referential_constraints WHERE (`

	
	sqlstr := origsqlstr + where.String() + ") " + order.String()

	var vals []*ReferentialConstraint
	q, err := db.Query(sqlstr, where.Values()...)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	for q.Next() {
		rc := ReferentialConstraint{}

		err = q.Scan(&rc.ConstraintCatalog, &rc.ConstraintSchema, &rc.ConstraintName, &rc.UniqueConstraintCatalog, &rc.UniqueConstraintSchema, &rc.UniqueConstraintName, &rc.MatchOption, &rc.UpdateRule, &rc.DeleteRule)
		if err != nil {
			return nil, errors.WithStack(err)
		}

		vals = append(vals, &rc)
	}
	return vals, nil
}

// AllReferentialConstraint retrieves all rows from 'information_schema.referential_constraints' as a slice of ReferentialConstraint.
func AllReferentialConstraint(db XODB, order OrderBy) ([]*ReferentialConstraint, error) {
	const origsqlstr = `SELECT ` +
		`constraint_catalog, constraint_schema, constraint_name, unique_constraint_catalog, unique_constraint_schema, unique_constraint_name, match_option, update_rule, delete_rule ` +
		`FROM information_schema.referential_constraints`

	sqlstr := origsqlstr + order.String()

	var vals []*ReferentialConstraint
	q, err := db.Query(sqlstr)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	for q.Next() {
		rc := ReferentialConstraint{}

		err = q.Scan(&rc.ConstraintCatalog, &rc.ConstraintSchema, &rc.ConstraintName, &rc.UniqueConstraintCatalog, &rc.UniqueConstraintSchema, &rc.UniqueConstraintName, &rc.MatchOption, &rc.UpdateRule, &rc.DeleteRule)
		if err != nil {
			return nil, errors.WithStack(err)
		}

		vals = append(vals, &rc)
	}
	return vals, nil
}
