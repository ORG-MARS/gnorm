// Package pg contains the types for schema 'information_schema'.
package pg

// GENERATED BY XO. DO NOT EDIT.

import (
	"github.com/pkg/errors"
)

// ApplicableRoleTable is the database name for the table.
const ApplicableRoleTable = "information_schema.applicable_roles"

// ApplicableRole represents a row from 'information_schema.applicable_roles'.
type ApplicableRole struct {
	Grantee     SQLIdentifier `yaml:"grantee,omitempty"`      // grantee
	RoleName    SQLIdentifier `yaml:"role_name,omitempty"`    // role_name
	IsGrantable YesOrNo       `yaml:"is_grantable,omitempty"` // is_grantable
}

// Constants defining each column in the table.
const (
	ApplicableRoleGranteeField     = "grantee"
	ApplicableRoleRoleNameField    = "role_name"
	ApplicableRoleIsGrantableField = "is_grantable"
)

// WhereClauses for every type in ApplicableRole.
var (
	ApplicableRoleGranteeWhere     SQLIdentifierField = "grantee"
	ApplicableRoleRoleNameWhere    SQLIdentifierField = "role_name"
	ApplicableRoleIsGrantableWhere YesOrNoField       = "is_grantable"
)

// QueryOneApplicableRole retrieves a row from 'information_schema.applicable_roles' as a ApplicableRole.
func QueryOneApplicableRole(db XODB, where WhereClause, order OrderBy) (*ApplicableRole, error) {
	const origsqlstr = `SELECT ` +
		`grantee, role_name, is_grantable ` +
		`FROM information_schema.applicable_roles WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") " + order.String() + " LIMIT 1"

	ar := &ApplicableRole{}
	err := db.QueryRow(sqlstr, where.Values()...).Scan(&ar.Grantee, &ar.RoleName, &ar.IsGrantable)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	return ar, nil
}

// QueryApplicableRole retrieves rows from 'information_schema.applicable_roles' as a slice of ApplicableRole.
func QueryApplicableRole(db XODB, where WhereClause, order OrderBy) ([]*ApplicableRole, error) {
	const origsqlstr = `SELECT ` +
		`grantee, role_name, is_grantable ` +
		`FROM information_schema.applicable_roles WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") " + order.String()

	var vals []*ApplicableRole
	q, err := db.Query(sqlstr, where.Values()...)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	for q.Next() {
		ar := ApplicableRole{}

		err = q.Scan(&ar.Grantee, &ar.RoleName, &ar.IsGrantable)
		if err != nil {
			return nil, errors.WithStack(err)
		}

		vals = append(vals, &ar)
	}
	return vals, nil
}

// AllApplicableRole retrieves all rows from 'information_schema.applicable_roles' as a slice of ApplicableRole.
func AllApplicableRole(db XODB, order OrderBy) ([]*ApplicableRole, error) {
	const origsqlstr = `SELECT ` +
		`grantee, role_name, is_grantable ` +
		`FROM information_schema.applicable_roles`

	sqlstr := origsqlstr + order.String()

	var vals []*ApplicableRole
	q, err := db.Query(sqlstr)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	for q.Next() {
		ar := ApplicableRole{}

		err = q.Scan(&ar.Grantee, &ar.RoleName, &ar.IsGrantable)
		if err != nil {
			return nil, errors.WithStack(err)
		}

		vals = append(vals, &ar)
	}
	return vals, nil
}
