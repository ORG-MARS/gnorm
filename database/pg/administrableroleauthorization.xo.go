// Package pg contains the types for schema 'information_schema'.
package pg

// GENERATED BY XO. DO NOT EDIT.

import (
	"github.com/pkg/errors"
)

// AdministrableRoleAuthorizationTable is the database name for the table.
const AdministrableRoleAuthorizationTable = "information_schema.administrable_role_authorizations"

// AdministrableRoleAuthorization represents a row from 'information_schema.administrable_role_authorizations'.
type AdministrableRoleAuthorization struct {
	Grantee     SQLIdentifier `json:"grantee"`      // grantee
	RoleName    SQLIdentifier `json:"role_name"`    // role_name
	IsGrantable YesOrNo       `json:"is_grantable"` // is_grantable
}

// Constants defining each column in the table.
const (
	AdministrableRoleAuthorizationGranteeField     = "grantee"
	AdministrableRoleAuthorizationRoleNameField    = "role_name"
	AdministrableRoleAuthorizationIsGrantableField = "is_grantable"
)

// WhereClauses for every type in AdministrableRoleAuthorization.
var (
	AdministrableRoleAuthorizationGranteeWhere     SQLIdentifierField = "grantee"
	AdministrableRoleAuthorizationRoleNameWhere    SQLIdentifierField = "role_name"
	AdministrableRoleAuthorizationIsGrantableWhere YesOrNoField       = "is_grantable"
)

// QueryOneAdministrableRoleAuthorization retrieves a row from 'information_schema.administrable_role_authorizations' as a AdministrableRoleAuthorization.
func QueryOneAdministrableRoleAuthorization(db XODB, where WhereClause, order OrderBy) (*AdministrableRoleAuthorization, error) {
	const origsqlstr = `SELECT ` +
		`grantee, role_name, is_grantable ` +
		`FROM information_schema.administrable_role_authorizations WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") " + order.String() + " LIMIT 1"

	ara := &AdministrableRoleAuthorization{}
	err := db.QueryRow(sqlstr, where.Values()...).Scan(&ara.Grantee, &ara.RoleName, &ara.IsGrantable)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	return ara, nil
}

// QueryAdministrableRoleAuthorization retrieves rows from 'information_schema.administrable_role_authorizations' as a slice of AdministrableRoleAuthorization.
func QueryAdministrableRoleAuthorization(db XODB, where WhereClause, order OrderBy) ([]*AdministrableRoleAuthorization, error) {
	const origsqlstr = `SELECT ` +
		`grantee, role_name, is_grantable ` +
		`FROM information_schema.administrable_role_authorizations WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") " + order.String()

	var vals []*AdministrableRoleAuthorization
	q, err := db.Query(sqlstr, where.Values()...)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	for q.Next() {
		ara := AdministrableRoleAuthorization{}

		err = q.Scan(&ara.Grantee, &ara.RoleName, &ara.IsGrantable)
		if err != nil {
			return nil, errors.WithStack(err)
		}

		vals = append(vals, &ara)
	}
	return vals, nil
}

// AllAdministrableRoleAuthorization retrieves all rows from 'information_schema.administrable_role_authorizations' as a slice of AdministrableRoleAuthorization.
func AllAdministrableRoleAuthorization(db XODB, order OrderBy) ([]*AdministrableRoleAuthorization, error) {
	const origsqlstr = `SELECT ` +
		`grantee, role_name, is_grantable ` +
		`FROM information_schema.administrable_role_authorizations`

	sqlstr := origsqlstr + order.String()

	var vals []*AdministrableRoleAuthorization
	q, err := db.Query(sqlstr)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	for q.Next() {
		ara := AdministrableRoleAuthorization{}

		err = q.Scan(&ara.Grantee, &ara.RoleName, &ara.IsGrantable)
		if err != nil {
			return nil, errors.WithStack(err)
		}

		vals = append(vals, &ara)
	}
	return vals, nil
}
