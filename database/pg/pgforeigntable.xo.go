// Package pg contains the types for schema 'information_schema'.
package pg

// GENERATED BY XO. DO NOT EDIT.

import (
	"database/sql"
)

// PgForeignTableTable is the database name for the table.
const PgForeignTableTable = "information_schema._pg_foreign_tables"

// PgForeignTable represents a row from 'information_schema._pg_foreign_tables'.
type PgForeignTable struct {
	ForeignTableCatalog     SQLIdentifier    `json:"foreign_table_catalog"`    // foreign_table_catalog
	ForeignTableSchema      SQLIdentifier    `json:"foreign_table_schema"`     // foreign_table_schema
	ForeignTableName        SQLIdentifier    `json:"foreign_table_name"`       // foreign_table_name
	Ftoptions               []sql.NullString `json:"ftoptions"`                // ftoptions
	ForeignServerCatalog    SQLIdentifier    `json:"foreign_server_catalog"`   // foreign_server_catalog
	ForeignServerName       SQLIdentifier    `json:"foreign_server_name"`      // foreign_server_name
	AuthorizationIdentifier SQLIdentifier    `json:"authorization_identifier"` // authorization_identifier
}

// Constants defining each column in the table.
const (
	PgForeignTableForeignTableCatalogField     = "foreign_table_catalog"
	PgForeignTableForeignTableSchemaField      = "foreign_table_schema"
	PgForeignTableForeignTableNameField        = "foreign_table_name"
	PgForeignTableFtoptionsField               = "ftoptions"
	PgForeignTableForeignServerCatalogField    = "foreign_server_catalog"
	PgForeignTableForeignServerNameField       = "foreign_server_name"
	PgForeignTableAuthorizationIdentifierField = "authorization_identifier"
)

// WhereClauses for every type in PgForeignTable.
var (
	PgForeignTableForeignTableCatalogWhere     SQLIdentifierField = "foreign_table_catalog"
	PgForeignTableForeignTableSchemaWhere      SQLIdentifierField = "foreign_table_schema"
	PgForeignTableForeignTableNameWhere        SQLIdentifierField = "foreign_table_name"
	PgForeignTableFtoptionsWhere               NullStringField    = "ftoptions"
	PgForeignTableForeignServerCatalogWhere    SQLIdentifierField = "foreign_server_catalog"
	PgForeignTableForeignServerNameWhere       SQLIdentifierField = "foreign_server_name"
	PgForeignTableAuthorizationIdentifierWhere SQLIdentifierField = "authorization_identifier"
)

// QueryOnePgForeignTable retrieves a row from 'information_schema._pg_foreign_tables' as a PgForeignTable.
func QueryOnePgForeignTable(db XODB, where WhereClause, order OrderBy) (*PgForeignTable, error) {
	const origsqlstr = `SELECT ` +
		`foreign_table_catalog, foreign_table_schema, foreign_table_name, ftoptions, foreign_server_catalog, foreign_server_name, authorization_identifier ` +
		`FROM information_schema._pg_foreign_tables WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") " + order.String() + " LIMIT 1"

	pft := &PgForeignTable{}
	err := db.QueryRow(sqlstr, where.Values()...).Scan(&pft.ForeignTableCatalog, &pft.ForeignTableSchema, &pft.ForeignTableName, &pft.Ftoptions, &pft.ForeignServerCatalog, &pft.ForeignServerName, &pft.AuthorizationIdentifier)
	if err != nil {
		return nil, err
	}
	return pft, nil
}

// QueryPgForeignTable retrieves rows from 'information_schema._pg_foreign_tables' as a slice of PgForeignTable.
func QueryPgForeignTable(db XODB, where WhereClause, order OrderBy) ([]*PgForeignTable, error) {
	const origsqlstr = `SELECT ` +
		`foreign_table_catalog, foreign_table_schema, foreign_table_name, ftoptions, foreign_server_catalog, foreign_server_name, authorization_identifier ` +
		`FROM information_schema._pg_foreign_tables WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") " + order.String()

	var vals []*PgForeignTable
	q, err := db.Query(sqlstr, where.Values()...)
	if err != nil {
		return nil, err
	}
	for q.Next() {
		pft := PgForeignTable{}

		err = q.Scan(&pft.ForeignTableCatalog, &pft.ForeignTableSchema, &pft.ForeignTableName, &pft.Ftoptions, &pft.ForeignServerCatalog, &pft.ForeignServerName, &pft.AuthorizationIdentifier)
		if err != nil {
			return nil, err
		}

		vals = append(vals, &pft)
	}
	return vals, nil
}
