// Package pg contains the types for schema 'information_schema'.
package pg

// GENERATED BY XO. DO NOT EDIT.

// ReferentialConstraintTable is the database name for the table.
const ReferentialConstraintTable = "information_schema.referential_constraints"

// ReferentialConstraint represents a row from 'information_schema.referential_constraints'.
type ReferentialConstraint struct {
	ConstraintCatalog       SQLIdentifier `json:"constraint_catalog"`        // constraint_catalog
	ConstraintSchema        SQLIdentifier `json:"constraint_schema"`         // constraint_schema
	ConstraintName          SQLIdentifier `json:"constraint_name"`           // constraint_name
	UniqueConstraintCatalog SQLIdentifier `json:"unique_constraint_catalog"` // unique_constraint_catalog
	UniqueConstraintSchema  SQLIdentifier `json:"unique_constraint_schema"`  // unique_constraint_schema
	UniqueConstraintName    SQLIdentifier `json:"unique_constraint_name"`    // unique_constraint_name
	MatchOption             CharacterData `json:"match_option"`              // match_option
	UpdateRule              CharacterData `json:"update_rule"`               // update_rule
	DeleteRule              CharacterData `json:"delete_rule"`               // delete_rule
}

// Constants defining each column in the table.
const (
	ReferentialConstraintConstraintCatalogField       = "constraint_catalog"
	ReferentialConstraintConstraintSchemaField        = "constraint_schema"
	ReferentialConstraintConstraintNameField          = "constraint_name"
	ReferentialConstraintUniqueConstraintCatalogField = "unique_constraint_catalog"
	ReferentialConstraintUniqueConstraintSchemaField  = "unique_constraint_schema"
	ReferentialConstraintUniqueConstraintNameField    = "unique_constraint_name"
	ReferentialConstraintMatchOptionField             = "match_option"
	ReferentialConstraintUpdateRuleField              = "update_rule"
	ReferentialConstraintDeleteRuleField              = "delete_rule"
)

// WhereClauses for every type in ReferentialConstraint.
var (
	ReferentialConstraintConstraintCatalogWhere       SQLIdentifierField = "constraint_catalog"
	ReferentialConstraintConstraintSchemaWhere        SQLIdentifierField = "constraint_schema"
	ReferentialConstraintConstraintNameWhere          SQLIdentifierField = "constraint_name"
	ReferentialConstraintUniqueConstraintCatalogWhere SQLIdentifierField = "unique_constraint_catalog"
	ReferentialConstraintUniqueConstraintSchemaWhere  SQLIdentifierField = "unique_constraint_schema"
	ReferentialConstraintUniqueConstraintNameWhere    SQLIdentifierField = "unique_constraint_name"
	ReferentialConstraintMatchOptionWhere             CharacterDataField = "match_option"
	ReferentialConstraintUpdateRuleWhere              CharacterDataField = "update_rule"
	ReferentialConstraintDeleteRuleWhere              CharacterDataField = "delete_rule"
)

// QueryOneReferentialConstraint retrieves a row from 'information_schema.referential_constraints' as a ReferentialConstraint.
func QueryOneReferentialConstraint(db XODB, where WhereClause, order OrderBy) (*ReferentialConstraint, error) {
	const origsqlstr = `SELECT ` +
		`constraint_catalog, constraint_schema, constraint_name, unique_constraint_catalog, unique_constraint_schema, unique_constraint_name, match_option, update_rule, delete_rule ` +
		`FROM information_schema.referential_constraints WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") " + order.String() + " LIMIT 1"

	rc := &ReferentialConstraint{}
	err := db.QueryRow(sqlstr, where.Values()...).Scan(&rc.ConstraintCatalog, &rc.ConstraintSchema, &rc.ConstraintName, &rc.UniqueConstraintCatalog, &rc.UniqueConstraintSchema, &rc.UniqueConstraintName, &rc.MatchOption, &rc.UpdateRule, &rc.DeleteRule)
	if err != nil {
		return nil, err
	}
	return rc, nil
}

// QueryReferentialConstraint retrieves rows from 'information_schema.referential_constraints' as a slice of ReferentialConstraint.
func QueryReferentialConstraint(db XODB, where WhereClause, order OrderBy) ([]*ReferentialConstraint, error) {
	const origsqlstr = `SELECT ` +
		`constraint_catalog, constraint_schema, constraint_name, unique_constraint_catalog, unique_constraint_schema, unique_constraint_name, match_option, update_rule, delete_rule ` +
		`FROM information_schema.referential_constraints WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") " + order.String()

	var vals []*ReferentialConstraint
	q, err := db.Query(sqlstr, where.Values()...)
	if err != nil {
		return nil, err
	}
	for q.Next() {
		rc := ReferentialConstraint{}

		err = q.Scan(&rc.ConstraintCatalog, &rc.ConstraintSchema, &rc.ConstraintName, &rc.UniqueConstraintCatalog, &rc.UniqueConstraintSchema, &rc.UniqueConstraintName, &rc.MatchOption, &rc.UpdateRule, &rc.DeleteRule)
		if err != nil {
			return nil, err
		}

		vals = append(vals, &rc)
	}
	return vals, nil
}
