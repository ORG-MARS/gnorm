// Package pg contains the types for schema 'information_schema'.
package pg

// GENERATED BY XO. DO NOT EDIT.

import (
	"github.com/pkg/errors"
)

// SchematumTable is the database name for the table.
const SchematumTable = "information_schema.schemata"

// Schematum represents a row from 'information_schema.schemata'.
type Schematum struct {
	CatalogName                SQLIdentifier `json:"catalog_name"`                  // catalog_name
	SchemaName                 SQLIdentifier `json:"schema_name"`                   // schema_name
	SchemaOwner                SQLIdentifier `json:"schema_owner"`                  // schema_owner
	DefaultCharacterSetCatalog SQLIdentifier `json:"default_character_set_catalog"` // default_character_set_catalog
	DefaultCharacterSetSchema  SQLIdentifier `json:"default_character_set_schema"`  // default_character_set_schema
	DefaultCharacterSetName    SQLIdentifier `json:"default_character_set_name"`    // default_character_set_name
	SQLPath                    CharacterData `json:"sql_path"`                      // sql_path
}

// Constants defining each column in the table.
const (
	SchematumCatalogNameField                = "catalog_name"
	SchematumSchemaNameField                 = "schema_name"
	SchematumSchemaOwnerField                = "schema_owner"
	SchematumDefaultCharacterSetCatalogField = "default_character_set_catalog"
	SchematumDefaultCharacterSetSchemaField  = "default_character_set_schema"
	SchematumDefaultCharacterSetNameField    = "default_character_set_name"
	SchematumSQLPathField                    = "sql_path"
)

// WhereClauses for every type in Schematum.
var (
	SchematumCatalogNameWhere                SQLIdentifierField = "catalog_name"
	SchematumSchemaNameWhere                 SQLIdentifierField = "schema_name"
	SchematumSchemaOwnerWhere                SQLIdentifierField = "schema_owner"
	SchematumDefaultCharacterSetCatalogWhere SQLIdentifierField = "default_character_set_catalog"
	SchematumDefaultCharacterSetSchemaWhere  SQLIdentifierField = "default_character_set_schema"
	SchematumDefaultCharacterSetNameWhere    SQLIdentifierField = "default_character_set_name"
	SchematumSQLPathWhere                    CharacterDataField = "sql_path"
)

// QueryOneSchematum retrieves a row from 'information_schema.schemata' as a Schematum.
func QueryOneSchematum(db XODB, where WhereClause, order OrderBy) (*Schematum, error) {
	const origsqlstr = `SELECT ` +
		`catalog_name, schema_name, schema_owner, default_character_set_catalog, default_character_set_schema, default_character_set_name, sql_path ` +
		`FROM information_schema.schemata WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") " + order.String() + " LIMIT 1"

	s := &Schematum{}
	err := db.QueryRow(sqlstr, where.Values()...).Scan(&s.CatalogName, &s.SchemaName, &s.SchemaOwner, &s.DefaultCharacterSetCatalog, &s.DefaultCharacterSetSchema, &s.DefaultCharacterSetName, &s.SQLPath)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	return s, nil
}

// QuerySchematum retrieves rows from 'information_schema.schemata' as a slice of Schematum.
func QuerySchematum(db XODB, where WhereClause, order OrderBy) ([]*Schematum, error) {
	const origsqlstr = `SELECT ` +
		`catalog_name, schema_name, schema_owner, default_character_set_catalog, default_character_set_schema, default_character_set_name, sql_path ` +
		`FROM information_schema.schemata WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") " + order.String()

	var vals []*Schematum
	q, err := db.Query(sqlstr, where.Values()...)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	for q.Next() {
		s := Schematum{}

		err = q.Scan(&s.CatalogName, &s.SchemaName, &s.SchemaOwner, &s.DefaultCharacterSetCatalog, &s.DefaultCharacterSetSchema, &s.DefaultCharacterSetName, &s.SQLPath)
		if err != nil {
			return nil, errors.WithStack(err)
		}

		vals = append(vals, &s)
	}
	return vals, nil
}

// AllSchematum retrieves all rows from 'information_schema.schemata' as a slice of Schematum.
func AllSchematum(db XODB, order OrderBy) ([]*Schematum, error) {
	const origsqlstr = `SELECT ` +
		`catalog_name, schema_name, schema_owner, default_character_set_catalog, default_character_set_schema, default_character_set_name, sql_path ` +
		`FROM information_schema.schemata`

	sqlstr := origsqlstr + order.String()

	var vals []*Schematum
	q, err := db.Query(sqlstr)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	for q.Next() {
		s := Schematum{}

		err = q.Scan(&s.CatalogName, &s.SchemaName, &s.SchemaOwner, &s.DefaultCharacterSetCatalog, &s.DefaultCharacterSetSchema, &s.DefaultCharacterSetName, &s.SQLPath)
		if err != nil {
			return nil, errors.WithStack(err)
		}

		vals = append(vals, &s)
	}
	return vals, nil
}
