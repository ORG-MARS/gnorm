// Package pg contains the types for schema 'information_schema'.
package pg

// GENERATED BY XO. DO NOT EDIT.

// SequenceTable is the database name for the table.
const SequenceTable = "information_schema.sequences"

// Sequence represents a row from 'information_schema.sequences'.
type Sequence struct {
	SequenceCatalog       SQLIdentifier  `json:"sequence_catalog"`        // sequence_catalog
	SequenceSchema        SQLIdentifier  `json:"sequence_schema"`         // sequence_schema
	SequenceName          SQLIdentifier  `json:"sequence_name"`           // sequence_name
	DataType              CharacterData  `json:"data_type"`               // data_type
	NumericPrecision      CardinalNumber `json:"numeric_precision"`       // numeric_precision
	NumericPrecisionRadix CardinalNumber `json:"numeric_precision_radix"` // numeric_precision_radix
	NumericScale          CardinalNumber `json:"numeric_scale"`           // numeric_scale
	StartValue            CharacterData  `json:"start_value"`             // start_value
	MinimumValue          CharacterData  `json:"minimum_value"`           // minimum_value
	MaximumValue          CharacterData  `json:"maximum_value"`           // maximum_value
	Increment             CharacterData  `json:"increment"`               // increment
	CycleOption           YesOrNo        `json:"cycle_option"`            // cycle_option
}

// Constants defining each column in the table.
const (
	SequenceSequenceCatalogField       = "sequence_catalog"
	SequenceSequenceSchemaField        = "sequence_schema"
	SequenceSequenceNameField          = "sequence_name"
	SequenceDataTypeField              = "data_type"
	SequenceNumericPrecisionField      = "numeric_precision"
	SequenceNumericPrecisionRadixField = "numeric_precision_radix"
	SequenceNumericScaleField          = "numeric_scale"
	SequenceStartValueField            = "start_value"
	SequenceMinimumValueField          = "minimum_value"
	SequenceMaximumValueField          = "maximum_value"
	SequenceIncrementField             = "increment"
	SequenceCycleOptionField           = "cycle_option"
)

// WhereClauses for every type in Sequence.
var (
	SequenceSequenceCatalogWhere       SQLIdentifierField  = "sequence_catalog"
	SequenceSequenceSchemaWhere        SQLIdentifierField  = "sequence_schema"
	SequenceSequenceNameWhere          SQLIdentifierField  = "sequence_name"
	SequenceDataTypeWhere              CharacterDataField  = "data_type"
	SequenceNumericPrecisionWhere      CardinalNumberField = "numeric_precision"
	SequenceNumericPrecisionRadixWhere CardinalNumberField = "numeric_precision_radix"
	SequenceNumericScaleWhere          CardinalNumberField = "numeric_scale"
	SequenceStartValueWhere            CharacterDataField  = "start_value"
	SequenceMinimumValueWhere          CharacterDataField  = "minimum_value"
	SequenceMaximumValueWhere          CharacterDataField  = "maximum_value"
	SequenceIncrementWhere             CharacterDataField  = "increment"
	SequenceCycleOptionWhere           YesOrNoField        = "cycle_option"
)

// QueryOneSequence retrieves a row from 'information_schema.sequences' as a Sequence.
func QueryOneSequence(db XODB, where WhereClause, order OrderBy) (*Sequence, error) {
	const origsqlstr = `SELECT ` +
		`sequence_catalog, sequence_schema, sequence_name, data_type, numeric_precision, numeric_precision_radix, numeric_scale, start_value, minimum_value, maximum_value, increment, cycle_option ` +
		`FROM information_schema.sequences WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") " + order.String() + " LIMIT 1"

	s := &Sequence{}
	err := db.QueryRow(sqlstr, where.Values()...).Scan(&s.SequenceCatalog, &s.SequenceSchema, &s.SequenceName, &s.DataType, &s.NumericPrecision, &s.NumericPrecisionRadix, &s.NumericScale, &s.StartValue, &s.MinimumValue, &s.MaximumValue, &s.Increment, &s.CycleOption)
	if err != nil {
		return nil, err
	}
	return s, nil
}

// QuerySequence retrieves rows from 'information_schema.sequences' as a slice of Sequence.
func QuerySequence(db XODB, where WhereClause, order OrderBy) ([]*Sequence, error) {
	const origsqlstr = `SELECT ` +
		`sequence_catalog, sequence_schema, sequence_name, data_type, numeric_precision, numeric_precision_radix, numeric_scale, start_value, minimum_value, maximum_value, increment, cycle_option ` +
		`FROM information_schema.sequences WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") " + order.String()

	var vals []*Sequence
	q, err := db.Query(sqlstr, where.Values()...)
	if err != nil {
		return nil, err
	}
	for q.Next() {
		s := Sequence{}

		err = q.Scan(&s.SequenceCatalog, &s.SequenceSchema, &s.SequenceName, &s.DataType, &s.NumericPrecision, &s.NumericPrecisionRadix, &s.NumericScale, &s.StartValue, &s.MinimumValue, &s.MaximumValue, &s.Increment, &s.CycleOption)
		if err != nil {
			return nil, err
		}

		vals = append(vals, &s)
	}
	return vals, nil
}
