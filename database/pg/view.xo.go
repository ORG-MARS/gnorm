// Package pg contains the types for schema 'information_schema'.
package pg

// GENERATED BY XO. DO NOT EDIT.

import (
	"github.com/pkg/errors"
)

// ViewTable is the database name for the table.
const ViewTable = "information_schema.views"

// View represents a row from 'information_schema.views'.
type View struct {
	TableCatalog            SQLIdentifier `json:"table_catalog"`              // table_catalog
	TableSchema             SQLIdentifier `json:"table_schema"`               // table_schema
	TableName               SQLIdentifier `json:"table_name"`                 // table_name
	ViewDefinition          CharacterData `json:"view_definition"`            // view_definition
	CheckOption             CharacterData `json:"check_option"`               // check_option
	IsUpdatable             YesOrNo       `json:"is_updatable"`               // is_updatable
	IsInsertableInto        YesOrNo       `json:"is_insertable_into"`         // is_insertable_into
	IsTriggerUpdatable      YesOrNo       `json:"is_trigger_updatable"`       // is_trigger_updatable
	IsTriggerDeletable      YesOrNo       `json:"is_trigger_deletable"`       // is_trigger_deletable
	IsTriggerInsertableInto YesOrNo       `json:"is_trigger_insertable_into"` // is_trigger_insertable_into
}

// Constants defining each column in the table.
const (
	ViewTableCatalogField            = "table_catalog"
	ViewTableSchemaField             = "table_schema"
	ViewTableNameField               = "table_name"
	ViewViewDefinitionField          = "view_definition"
	ViewCheckOptionField             = "check_option"
	ViewIsUpdatableField             = "is_updatable"
	ViewIsInsertableIntoField        = "is_insertable_into"
	ViewIsTriggerUpdatableField      = "is_trigger_updatable"
	ViewIsTriggerDeletableField      = "is_trigger_deletable"
	ViewIsTriggerInsertableIntoField = "is_trigger_insertable_into"
)

// WhereClauses for every type in View.
var (
	ViewTableCatalogWhere            SQLIdentifierField = "table_catalog"
	ViewTableSchemaWhere             SQLIdentifierField = "table_schema"
	ViewTableNameWhere               SQLIdentifierField = "table_name"
	ViewViewDefinitionWhere          CharacterDataField = "view_definition"
	ViewCheckOptionWhere             CharacterDataField = "check_option"
	ViewIsUpdatableWhere             YesOrNoField       = "is_updatable"
	ViewIsInsertableIntoWhere        YesOrNoField       = "is_insertable_into"
	ViewIsTriggerUpdatableWhere      YesOrNoField       = "is_trigger_updatable"
	ViewIsTriggerDeletableWhere      YesOrNoField       = "is_trigger_deletable"
	ViewIsTriggerInsertableIntoWhere YesOrNoField       = "is_trigger_insertable_into"
)

// QueryOneView retrieves a row from 'information_schema.views' as a View.
func QueryOneView(db XODB, where WhereClause, order OrderBy) (*View, error) {
	const origsqlstr = `SELECT ` +
		`table_catalog, table_schema, table_name, view_definition, check_option, is_updatable, is_insertable_into, is_trigger_updatable, is_trigger_deletable, is_trigger_insertable_into ` +
		`FROM information_schema.views WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") " + order.String() + " LIMIT 1"

	v := &View{}
	err := db.QueryRow(sqlstr, where.Values()...).Scan(&v.TableCatalog, &v.TableSchema, &v.TableName, &v.ViewDefinition, &v.CheckOption, &v.IsUpdatable, &v.IsInsertableInto, &v.IsTriggerUpdatable, &v.IsTriggerDeletable, &v.IsTriggerInsertableInto)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	return v, nil
}

// QueryView retrieves rows from 'information_schema.views' as a slice of View.
func QueryView(db XODB, where WhereClause, order OrderBy) ([]*View, error) {
	const origsqlstr = `SELECT ` +
		`table_catalog, table_schema, table_name, view_definition, check_option, is_updatable, is_insertable_into, is_trigger_updatable, is_trigger_deletable, is_trigger_insertable_into ` +
		`FROM information_schema.views WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") " + order.String()

	var vals []*View
	q, err := db.Query(sqlstr, where.Values()...)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	for q.Next() {
		v := View{}

		err = q.Scan(&v.TableCatalog, &v.TableSchema, &v.TableName, &v.ViewDefinition, &v.CheckOption, &v.IsUpdatable, &v.IsInsertableInto, &v.IsTriggerUpdatable, &v.IsTriggerDeletable, &v.IsTriggerInsertableInto)
		if err != nil {
			return nil, errors.WithStack(err)
		}

		vals = append(vals, &v)
	}
	return vals, nil
}

// AllView retrieves all rows from 'information_schema.views' as a slice of View.
func AllView(db XODB, order OrderBy) ([]*View, error) {
	const origsqlstr = `SELECT ` +
		`table_catalog, table_schema, table_name, view_definition, check_option, is_updatable, is_insertable_into, is_trigger_updatable, is_trigger_deletable, is_trigger_insertable_into ` +
		`FROM information_schema.views`

	sqlstr := origsqlstr + order.String()

	var vals []*View
	q, err := db.Query(sqlstr)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	for q.Next() {
		v := View{}

		err = q.Scan(&v.TableCatalog, &v.TableSchema, &v.TableName, &v.ViewDefinition, &v.CheckOption, &v.IsUpdatable, &v.IsInsertableInto, &v.IsTriggerUpdatable, &v.IsTriggerDeletable, &v.IsTriggerInsertableInto)
		if err != nil {
			return nil, errors.WithStack(err)
		}

		vals = append(vals, &v)
	}
	return vals, nil
}
